# AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Jérôme Fenal <jfenal@gmail.com>, 2013
msgid ""
msgstr ""
"Project-Id-Version: Defensive Coding Guide\n"
"POT-Creation-Date: 2013-03-12T03:19:44\n"
"PO-Revision-Date: 2013-03-24 17:40+0000\n"
"Last-Translator: Jérôme Fenal <jfenal@gmail.com>\n"
"Language-Team: French <trans-fr@lists.fedoraproject.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fr\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#. Tag: programlisting
#, no-c-format
msgid ""
"\n"
"// Create the connection object.\n"
"SSL *ssl = SSL_new(ctx);\n"
"if (ssl == NULL) {\n"
"  ERR_print_errors(bio_err);\n"
"  exit(1);\n"
"}\n"
"SSL_set_fd(ssl, sockfd);\n"
"\n"
"// Enable the ServerNameIndication extension\n"
"if (!SSL_set_tlsext_host_name(ssl, host)) {\n"
"  ERR_print_errors(bio_err);\n"
"  exit(1);\n"
"}\n"
"\n"
"// Perform the TLS handshake with the server.\n"
"ret = SSL_connect(ssl);\n"
"if (ret != 1) {\n"
"  // Error status can be 0 or negative.\n"
"  ssl_print_error_and_exit(ssl, \"SSL_connect\", ret);\n"
"}\n"
"\n"
"// Obtain the server certificate.\n"
"X509 *peercert = SSL_get_peer_certificate(ssl);\n"
"if (peercert == NULL) {\n"
"  fprintf(stderr, \"peer certificate missing\");\n"
"  exit(1);\n"
"}\n"
"\n"
"// Check the certificate verification result.  Allow an explicit\n"
"// certificate validation override in case verification fails.\n"
"int verifystatus = SSL_get_verify_result(ssl);\n"
"if (verifystatus != X509_V_OK &amp;&amp; !certificate_validity_override(peercert)) {\n"
"  fprintf(stderr, \"SSL_connect: verify result: %s\n"
"\",\n"
"\t    X509_verify_cert_error_string(verifystatus));\n"
"  exit(1);\n"
"}\n"
"\n"
"// Check if the server certificate matches the host name used to\n"
"// establish the connection.\n"
"// FIXME: Currently needs OpenSSL 1.1.\n"
"if (X509_check_host(peercert, (const unsigned char *)host, strlen(host),\n"
"\t\t      0) != 1\n"
"    &amp;&amp; !certificate_host_name_override(peercert, host)) {\n"
"  fprintf(stderr, \"SSL certificate does not match host name\n"
"\");\n"
"  exit(1);\n"
"}\n"
"\n"
"X509_free(peercert);\n"
"\n"
msgstr "\n// Crée l'objet connexion.\nSSL *ssl = SSL_new(ctx);\nif (ssl == NULL) {\n  ERR_print_errors(bio_err);\n  exit(1);\n}\nSSL_set_fd(ssl, sockfd);\n\n// Active l'extension ServerNameIndication\nif (!SSL_set_tlsext_host_name(ssl, host)) {\n  ERR_print_errors(bio_err);\n  exit(1);\n}\n\n// Réalise la poignée de main avec le serveur.\nret = SSL_connect(ssl);\nif (ret != 1) {\n  // Error status can be 0 or negative.\n  ssl_print_error_and_exit(ssl, \"SSL_connect\", ret);\n}\n\n// Récupère le certificat du serveur.\nX509 *peercert = SSL_get_peer_certificate(ssl);\nif (peercert == NULL) {\n  fprintf(stderr, \"peer certificate missing\");\n  exit(1);\n}\n\n// Vérifie le résultat de la vérification du certificat. Autorise une dérogation\n// explicite en case d'échec de la vérification du certificat.\nint verifystatus = SSL_get_verify_result(ssl);\nif (verifystatus != X509_V_OK &amp;&amp; !certificate_validity_override(peercert)) {\n  fprintf(stderr, \"SSL_connect: verify result: %s\n\",\n\t    X509_verify_cert_error_string(verifystatus));\n  exit(1);\n}\n\n// Vérifie que le certificat du serveur correspond au nom d'hôte utilisé\n// pour établir la connexion.\n// FIXME: Nécessite OpenSSL 1.1.\nif (X509_check_host(peercert, (const unsigned char *)host, strlen(host),\n\t\t      0) != 1\n    &amp;&amp; !certificate_host_name_override(peercert, host)) {\n  fprintf(stderr, \"SSL certificate does not match host name\n\");\n  exit(1);\n}\n\nX509_free(peercert);\n\n"
