<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 9. Serialization and Deserialization</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 2.8" /><meta name="package" content="Defensive_Coding-Defensive_Coding-1-en-US-1.0-20" /><link rel="home" href="index.html" title="Defensive Coding" /><link rel="up" href="pt02.html" title="Part II. Specific Programming Tasks" /><link rel="prev" href="sect-Defensive_Coding-Tasks-Processes-Fork-Parallel.html" title="8.6. fork as a primitive for parallelism" /><link rel="next" href="ch09s02.html" title="9.2. Protocol design" /></head><body><p id="title"><a class="left" href="http://www.redhat.com"><img src="Common_Content/images/image_left.png" alt="Product Site" /></a><a class="right" href="http://docs.redhat.com"><img src="Common_Content/images/image_right.png" alt="Documentation Site" /></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="sect-Defensive_Coding-Tasks-Processes-Fork-Parallel.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ch09s02.html"><strong>Next</strong></a></li></ul><div xml:lang="en-US" class="chapter" id="chap-Defensive_Coding-Tasks-Serialization" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 9. Serialization and Deserialization</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="chap-Defensive_Coding-Tasks-Serialization.html#sect-Defensive_Coding-Tasks-Serialization-Decoders">9.1. Recommendations for manually written decoders</a></span></dt><dt><span class="section"><a href="ch09s02.html">9.2. Protocol design</a></span></dt><dt><span class="section"><a href="ch09s03.html">9.3. Library support for deserialization</a></span></dt><dt><span class="section"><a href="sect-Defensive_Coding-Tasks-Serialization-XML.html">9.4. XML serialization</a></span></dt><dd><dl><dt><span class="section"><a href="sect-Defensive_Coding-Tasks-Serialization-XML.html#sect-Defensive_Coding-Tasks-Serialization-XML-External">9.4.1. External references</a></span></dt><dt><span class="section"><a href="sect-Defensive_Coding-Tasks-Serialization-XML-Entities.html">9.4.2. Entity expansion</a></span></dt><dt><span class="section"><a href="sect-Defensive_Coding-Tasks-Serialization-XML-XInclude.html">9.4.3. XInclude processing</a></span></dt><dt><span class="section"><a href="sect-Defensive_Coding-Tasks-Serialization-XML-Validation.html">9.4.4. Algorithmic complexity of XML validation</a></span></dt><dt><span class="section"><a href="sect-Defensive_Coding-Tasks-Serialization-XML-Expat.html">9.4.5. Using Expat for XML parsing</a></span></dt><dt><span class="section"><a href="sect-Defensive_Coding-Tasks-Serialization-XML-OpenJDK_Parse.html">9.4.6. Using OpenJDK for XML parsing and validation</a></span></dt></dl></dd><dt><span class="section"><a href="ch09s05.html">9.5. Protocol Encoders</a></span></dt></dl></div><div class="para">
		Protocol decoders and file format parsers are often the most-exposed part of an application because they are exposed with little or no user interaction and before any authentication and security checks are made. They are also difficult to write robustly in languages which are not memory-safe.
	</div><div class="section" id="sect-Defensive_Coding-Tasks-Serialization-Decoders"><div class="titlepage"><div><div><h2 class="title">9.1. Recommendations for manually written decoders</h2></div></div></div><div class="para">
			For C and C++, the advice in <a class="xref" href="chap-Defensive_Coding-C.html#sect-Defensive_Coding-C-Pointers">Section 1.1.2, “Recommendations for pointers and array handling”</a> applies. In addition, avoid non-character pointers directly into input buffers. Pointer misalignment causes crashes on some architectures.
		</div><div class="para">
			When reading variable-sized objects, do not allocate large amounts of data solely based on the value of a size field. If possible, grow the data structure as more data is read from the source, and stop when no data is available. This helps to avoid denial-of-service attacks where little amounts of input data results in enormous memory allocations during decoding. Alternatively, you can impose reasonable bounds on memory allocations, but some protocols do not permit this.
		</div></div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="sect-Defensive_Coding-Tasks-Processes-Fork-Parallel.html"><strong>Prev</strong>8.6. fork as a primitive for parallelism</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="ch09s02.html"><strong>Next</strong>9.2. Protocol design</a></li></ul></body></html>