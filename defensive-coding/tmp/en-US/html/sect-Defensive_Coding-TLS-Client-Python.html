<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>12.2.5. Implementing TLS Clients With Python</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 2.8" /><meta name="package" content="Defensive_Coding-Defensive_Coding-1-en-US-1.0-20" /><link rel="home" href="index.html" title="Defensive Coding" /><link rel="up" href="sect-Defensive_Coding-TLS-Client.html" title="12.2. TLS Clients" /><link rel="prev" href="sect-Defensive_Coding-TLS-Client-NSS.html" title="12.2.4. Implementing TLS Clients With NSS" /></head><body><p id="title"><a class="left" href="http://www.redhat.com"><img src="Common_Content/images/image_left.png" alt="Product Site" /></a><a class="right" href="http://docs.redhat.com"><img src="Common_Content/images/image_right.png" alt="Documentation Site" /></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="sect-Defensive_Coding-TLS-Client-NSS.html"><strong>Prev</strong></a></li><li class="next"></li></ul><div class="section" id="sect-Defensive_Coding-TLS-Client-Python"><div class="titlepage"><div><div><h3 class="title">12.2.5. Implementing TLS Clients With Python</h3></div></div></div><div class="para">
				The Python distribution provides a TLS implementation in the <code class="literal">ssl</code> module (actually a wrapper around OpenSSL). The exported interface is somewhat restricted, so that the client code shown below does not fully implement the recommendations in <a class="xref" href="chap-Defensive_Coding-TLS.html#sect-Defensive_Coding-TLS-OpenSSL">Section 12.1.1, “OpenSSL Pitfalls”</a>.
			</div><div class="important"><div class="admonition_header"><h2>Important</h2></div><div class="admonition"><div class="para">
					Currently, most Python function which accept <code class="literal">https://</code> URLs or otherwise implement HTTPS support do not perform certificate validation at all. (For example, this is true for the <code class="literal">httplib</code> and <code class="literal">xmlrpclib</code> modules.) If you use HTTPS, you should not use the built-in HTTP clients. The <code class="literal">Curl</code> class in the <code class="literal">curl</code> module, as provided by the <code class="literal">python-pycurl</code> package implements proper certificate validation.
				</div></div></div><div class="para">
				The <code class="literal">ssl</code> module currently does not perform host name checking on the server certificate. <a class="xref" href="sect-Defensive_Coding-TLS-Client-Python.html#ex-Defensive_Coding-TLS-Client-Python-check_host_name">Example 12.26, “Implementing TLS host name checking Python (without wildcard support)”</a> shows how to implement certificate matching, using the parsed certificate returned by <code class="function">getpeercert</code>.
			</div><div class="example" id="ex-Defensive_Coding-TLS-Client-Python-check_host_name"><h6>Example 12.26. Implementing TLS host name checking Python (without wildcard support)</h6><div class="example-contents"><pre xml:lang="en-US" class="programlisting" lang="en-US">
<span class="perl_Keyword">def</span> check_host_name<span class="perl_Char">(peercert</span>, name<span class="perl_Char">):</span>
    <span class="perl_Comment">"""Simple certificate/host name checker.  Returns True if the</span><span class="perl_Comment"></span>
<span class="perl_Comment"></span><span class="perl_Comment">    certificate matches, False otherwise.  Does not support</span><span class="perl_Comment"></span>
<span class="perl_Comment"></span><span class="perl_Comment">    wildcards."""</span>
    # Check that the peer has supplied a certificate.
    # <span class="perl_Others">None</span><span class="perl_Char">/{}</span> <span class="perl_Keyword">is</span> <span class="perl_Keyword">not</span> acceptable.
    <span class="perl_Keyword">if</span> <span class="perl_Keyword">not</span> peercert<span class="perl_Char">:</span>
        <span class="perl_Keyword">return</span> <span class="perl_Others">False</span>
    <span class="perl_Keyword">if</span> peercert.has_key<span class="perl_Char">(</span><span class="perl_String">"subjectAltName"</span><span class="perl_Char">):</span>
        <span class="perl_Keyword">for</span> typ, val <span class="perl_Keyword">in</span> peercert<span class="perl_Char">[</span><span class="perl_String">"subjectAltName"</span><span class="perl_Char">]:</span>
            <span class="perl_Keyword">if</span> typ <span class="perl_Char">==</span> <span class="perl_String">"DNS"</span> <span class="perl_Keyword">and</span> val <span class="perl_Char">==</span> name<span class="perl_Char">:</span>
                <span class="perl_Keyword">return</span> <span class="perl_Others">True</span>
    <span class="perl_Keyword">else</span><span class="perl_Char">:</span>
        # Only check the subject DN <span class="perl_Keyword">if</span> there <span class="perl_Keyword">is</span> no subject alternative
        # name.
        cn <span class="perl_Char">=</span> <span class="perl_Others">None</span>
        <span class="perl_Keyword">for</span> attr, val <span class="perl_Keyword">in</span> peercert<span class="perl_Char">[</span><span class="perl_String">"subject"</span><span class="perl_Char">]:</span>
            # Use most<span class="perl_Char">-specific</span> <span class="perl_Char">(last)</span> commonName attribute.
            <span class="perl_Keyword">if</span> attr <span class="perl_Char">==</span> <span class="perl_String">"commonName"</span><span class="perl_Char">:</span>
                cn <span class="perl_Char">=</span> val
        <span class="perl_Keyword">if</span> cn <span class="perl_Keyword">is</span> <span class="perl_Keyword">not</span> <span class="perl_Others">None</span><span class="perl_Char">:</span>
            <span class="perl_Keyword">return</span> cn <span class="perl_Char">==</span> name
    <span class="perl_Keyword">return</span> <span class="perl_Others">False</span>
</pre></div></div><br class="example-break" /><div class="para">
				To turn a regular, connected TCP socket into a TLS-enabled socket, use the <code class="function">ssl.wrap_socket</code> function. The function call in <a class="xref" href="sect-Defensive_Coding-TLS-Client-Python.html#ex-Defensive_Coding-TLS-Client-Python-Connect">Example 12.27, “Establishing a TLS client connection with Python”</a> provides additional arguments to override questionable defaults in OpenSSL and in the Python module.
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">ciphers="HIGH:-aNULL:-eNULL:-PSK:RC4-SHA:RC4-MD5"</code> selects relatively strong cipher suites with certificate-based authentication. (The call to <code class="function">check_host_name</code> function provides additional protection against anonymous cipher suites.)
					</div></li><li class="listitem"><div class="para">
						<code class="literal">ssl_version=ssl.PROTOCOL_TLSv1</code> disables SSL 2.0 support. By default, the <code class="literal">ssl</code> module sends an SSL 2.0 client hello, which is rejected by some servers. Ideally, we would request OpenSSL to negotiated the most recent TLS version supported by the server and the client, but the Python module does not allow this.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">cert_reqs=ssl.CERT_REQUIRED</code> turns on certificate validation.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">ca_certs='/etc/ssl/certs/ca-bundle.crt'</code> initializes the certificate store with a set of trusted root CAs. Unfortunately, it is necessary to hard-code this path into applications because the default path in OpenSSL is not available through the Python <code class="literal">ssl</code> module.
					</div></li></ul></div><div class="para">
				The <code class="literal">ssl</code> module (and OpenSSL) perform certificate validation, but the certificate must be compared manually against the host name, by calling the <code class="function">check_host_name</code> defined above.
			</div><div class="example" id="ex-Defensive_Coding-TLS-Client-Python-Connect"><h6>Example 12.27. Establishing a TLS client connection with Python</h6><div class="example-contents"><pre xml:lang="en-US" class="programlisting" lang="en-US">
sock <span class="perl_Char">=</span> ssl.wrap_socket<span class="perl_Char">(sock</span>,
                       ciphers<span class="perl_Char">=</span><span class="perl_String">"HIGH:-aNULL:-eNULL:-PSK:RC4-SHA:RC4-MD5"</span>,
                       ssl_version<span class="perl_Char">=ssl</span>.PROTOCOL_TLSv1,
                       cert_reqs<span class="perl_Char">=ssl</span>.CERT_REQUIRED,
                       ca_certs<span class="perl_Char">=</span><span class="perl_String">'/etc/ssl/certs/ca-bundle.crt'</span><span class="perl_Char">)</span>
# getpeercert<span class="perl_Char">()</span> triggers the handshake <span class="perl_Char">as</span> a side effect.
<span class="perl_Keyword">if</span> <span class="perl_Keyword">not</span> check_host_name<span class="perl_Char">(sock</span>.getpeercert<span class="perl_Char">()</span>, host<span class="perl_Char">):</span>
    <span class="perl_Keyword">raise</span> IOError<span class="perl_Char">(</span><span class="perl_String">"peer certificate does not match host name"</span><span class="perl_Char">)</span>
</pre></div></div><br class="example-break" /><div class="para">
				After the connection has been established, the TLS socket can be used like a regular socket:
			</div><div class="informalexample"><pre xml:lang="en-US" class="programlisting" lang="en-US">
sock.write<span class="perl_Char">(</span><span class="perl_String">"GET / HTTP/1.1\r\nHost: "</span> <span class="perl_Char">+</span> host <span class="perl_Char">+</span> <span class="perl_String">"\r\n\r\n"</span><span class="perl_Char">)</span>
<span class="perl_Keyword">print</span> sock.read<span class="perl_Char">()</span>
</pre></div><div class="para">
				Closing the TLS socket is straightforward as well:
			</div><div class="informalexample"><pre xml:lang="en-US" class="programlisting" lang="en-US">
sock.close<span class="perl_Char">()</span>
</pre></div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="sect-Defensive_Coding-TLS-Client-NSS.html"><strong>Prev</strong>12.2.4. Implementing TLS Clients With NSS</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li></ul></body></html>