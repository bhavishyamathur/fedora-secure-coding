<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 5. File Descriptor Management</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 2.8" /><meta name="package" content="Defensive_Coding-Defensive_Coding-1-en-US-1.0-20" /><link rel="home" href="index.html" title="Defensive Coding" /><link rel="up" href="pt02.html" title="Part II. Specific Programming Tasks" /><link rel="prev" href="ch04s04.html" title="4.4. Process attributes" /><link rel="next" href="sect-Defensive_Coding-Tasks-Descriptors-Child_Processes.html" title="5.2. Preventing file descriptor leaks to child processes" /></head><body><p id="title"><a class="left" href="http://www.redhat.com"><img src="Common_Content/images/image_left.png" alt="Product Site" /></a><a class="right" href="http://docs.redhat.com"><img src="Common_Content/images/image_right.png" alt="Documentation Site" /></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="ch04s04.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="sect-Defensive_Coding-Tasks-Descriptors-Child_Processes.html"><strong>Next</strong></a></li></ul><div xml:lang="en-US" class="chapter" id="sect-Defensive_Coding-Tasks-Descriptors" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 5. File Descriptor Management</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sect-Defensive_Coding-Tasks-Descriptors.html#idp32921344">5.1. Closing descriptors</a></span></dt><dd><dl><dt><span class="section"><a href="sect-Defensive_Coding-Tasks-Descriptors.html#idp19334016">5.1.1. Error handling during descriptor close</a></span></dt><dt><span class="section"><a href="sect-Defensive_Coding-Tasks-Descriptors.html#idp25179760">5.1.2. Closing descriptors and race conditions</a></span></dt><dt><span class="section"><a href="sect-Defensive_Coding-Tasks-Descriptors.html#idp24877360">5.1.3. Lingering state after close</a></span></dt></dl></dd><dt><span class="section"><a href="sect-Defensive_Coding-Tasks-Descriptors-Child_Processes.html">5.2. Preventing file descriptor leaks to child processes</a></span></dt><dt><span class="section"><a href="sect-Defensive_Coding-Tasks-Descriptors-Limit.html">5.3. Dealing with the <code class="function">select</code> limit</a></span></dt></dl></div><div class="para">
		File descriptors underlie all input/output mechanisms offered by the system. They are used to implementation the <code class="literal">FILE *</code>-based functions found in <code class="literal">&lt;stdio.h&gt;</code>, and all the file and network communication facilities provided by the Python and Java environments are eventually implemented in them.
	</div><div class="para">
		File descriptors are small, non-negative integers in userspace, and are backed on the kernel side with complicated data structures which can sometimes grow very large.
	</div><div class="section" id="idp32921344"><div class="titlepage"><div><div><h2 class="title" id="idp32921344">5.1. Closing descriptors</h2></div></div></div><div class="para">
			If a descriptor is no longer used by a program and is not closed explicitly, its number cannot be reused (which is problematic in itself, see <a class="xref" href="sect-Defensive_Coding-Tasks-Descriptors-Limit.html">Section 5.3, “Dealing with the <code class="function">select</code> limit”</a>), and the kernel resources are not freed. Therefore, it is important to close all descriptors at the earlierst point in time possible, but not earlier.
		</div><div class="section" id="idp19334016"><div class="titlepage"><div><div><h3 class="title" id="idp19334016">5.1.1. Error handling during descriptor close</h3></div></div></div><div class="para">
				The <code class="function">close</code> system call is always successful in the sense that the passed file descriptor is never valid after the function has been called. However, <code class="function">close</code> still can return an error, for example if there was a file system failure. But this error is not very useful because the absence of an error does not mean that all caches have been emptied and previous writes have been made durable. Programs which need such guarantees must open files with <code class="literal">O_SYNC</code> or use <code class="literal">fsync</code> or <code class="literal">fdatasync</code>, and may also have to <code class="literal">fsync</code> the directory containing the file.
			</div></div><div class="section" id="idp25179760"><div class="titlepage"><div><div><h3 class="title" id="idp25179760">5.1.2. Closing descriptors and race conditions</h3></div></div></div><div class="para">
				Unlike process IDs, which are recycle only gradually, the kernel always allocates the lowest unused file descriptor when a new descriptor is created. This means that in a multi-threaded program which constantly opens and closes file descriptors, descriptors are reused very quickly. Unless descriptor closing and other operations on the same file descriptor are synchronized (typically, using a mutex), there will be race coniditons and I/O operations will be applied to the wrong file descriptor.
			</div><div class="para">
				Sometimes, it is necessary to close a file descriptor concurrently, while another thread might be about to use it in a system call. In order to support this, a program needs to create a single special file descriptor, one on which all I/O operations fail. One way to achieve this is to use <code class="function">socketpair</code>, close one of the descriptors, and call <code class="literal">shutdown(fd, SHUTRDWR)</code> on the other.
			</div><div class="para">
				When a descriptor is closed concurrently, the program does not call <code class="function">close</code> on the descriptor. Instead it program uses <code class="function">dup2</code> to replace the descriptor to be closed with the dummy descriptor created earlier. This way, the kernel will not reuse the descriptor, but it will carry out all other steps associated with calling a descriptor (for instance, if the descriptor refers to a stream socket, the peer will be notified).
			</div><div class="para">
				This is just a sketch, and many details are missing. Additional data structures are needed to determine when it is safe to really close the descriptor, and proper locking is required for that.
			</div></div><div class="section" id="idp24877360"><div class="titlepage"><div><div><h3 class="title" id="idp24877360">5.1.3. Lingering state after close</h3></div></div></div><div class="para">
				By default, closing a stream socket returns immediately, and the kernel will try to send the data in the background. This means that it is impossible to implement accurate accounting of network-related resource utilization from userspace.
			</div><div class="para">
				The <code class="literal">SO_LINGER</code> socket option alters the behavior of <code class="function">close</code>, so that it will return only after the lingering data has been processed, either by sending it to the peer successfully, or by discarding it after the configured timeout. However, there is no interface which could perform this operation in the background, so a separate userspace thread is needed for each <code class="function">close</code> call, causing scalability issues.
			</div><div class="para">
				Currently, there is no application-level countermeasure which applies universally. Mitigation is possible with <span class="application"><strong>iptables</strong></span> (the <code class="literal">connlimit</code> match type in particular) and specialized filtering devices for denial-of-service network traffic.
			</div><div class="para">
				These problems are not related to the <code class="literal">TIME_WAIT</code> state commonly seen in <span class="application"><strong>netstat</strong></span> output. The kernel automatically expires such sockets if necessary.
			</div></div></div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="ch04s04.html"><strong>Prev</strong>4.4. Process attributes</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="sect-Defensive_Coding-Tasks-Descriptors-Child_Processes.html"><strong>Next</strong>5.2. Preventing file descriptor leaks to child pr...</a></li></ul></body></html>