<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>1.3.2. alloca and other forms of stack-based allocation</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 2.8" /><meta name="package" content="Defensive_Coding-Defensive_Coding-1-en-US-1.0-20" /><link rel="home" href="index.html" title="Defensive Coding" /><link rel="up" href="sect-Defensive_Coding-C-Allocators.html" title="1.3. Memory allocators" /><link rel="prev" href="sect-Defensive_Coding-C-Allocators.html" title="1.3. Memory allocators" /><link rel="next" href="sect-Defensive_Coding-C-Allocators-Arrays.html" title="1.3.3. Array allocation" /></head><body><p id="title"><a class="left" href="http://www.redhat.com"><img src="Common_Content/images/image_left.png" alt="Product Site" /></a><a class="right" href="http://docs.redhat.com"><img src="Common_Content/images/image_right.png" alt="Documentation Site" /></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="sect-Defensive_Coding-C-Allocators.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="sect-Defensive_Coding-C-Allocators-Arrays.html"><strong>Next</strong></a></li></ul><div class="section" id="sect-Defensive_Coding-C-Allocators-alloca"><div class="titlepage"><div><div><h3 class="title">1.3.2. <code class="function">alloca</code> and other forms of stack-based allocation</h3></div></div></div><div class="para">
			Allocation on the stack is risky because stack overflow checking is implicit. There is a guard page at the end of the memory area reserved for the stack. If the program attempts to read from or write to this guard page, a <code class="literal">SIGSEGV</code> signal is generated and the program typically terminates.
		</div><div class="para">
			This is sufficient for detecting typical stack overflow situations such as unbounded recursion, but it fails when the stack grows in increments larger than the size of the guard page. In this case, it is possible that the stack pointer ends up pointing into a memory area which has been allocated for a different purposes. Such misbehavior can be exploitable.
		</div><div class="para">
			A common source for large stack growth are calls to <code class="function">alloca</code> and related functions such as <code class="function">strdupa</code>. These functions should be avoided because of the lack of error checking. (They can be used safely if the allocated size is less than the page size (typically, 4096 bytes), but this case is relatively rare.) Additionally, relying on <code class="function">alloca</code> makes it more difficult to reorgnize the code because it is not allowed to use the pointer after the function calling <code class="function">alloca</code> has returned, even if this function has been inlined into its caller.
		</div><div class="para">
			Similar concerns apply to <span class="emphasis"><em>variable-length arrays</em></span> (VLAs), a feature of the C99 standard which started as a GNU extension. For large objects exceeding the page size, there is no error checking, either.
		</div><div class="para">
			In both cases, negative or very large sizes can trigger a stack-pointer wraparound, and the stack pointer and end up pointing into caller stack frames, which is fatal and can be exploitable.
		</div><div class="para">
			If you want to use <code class="function">alloca</code> or VLAs for performance reasons, consider using a small on-stack array (less than the page size, large enough to fulfill most requests). If the requested size is small enough, use the on-stack array. Otherwise, call <code class="function">malloc</code>. When exiting the function, check if <code class="function">malloc</code> had been called, and free the buffer as needed.
		</div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="sect-Defensive_Coding-C-Allocators.html"><strong>Prev</strong>1.3. Memory allocators</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="sect-Defensive_Coding-C-Allocators-Arrays.html"><strong>Next</strong>1.3.3. Array allocation</a></li></ul></body></html>