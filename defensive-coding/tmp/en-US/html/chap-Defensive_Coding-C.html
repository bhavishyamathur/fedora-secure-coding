<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 1. The C Programming Language</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 2.8" /><meta name="package" content="Defensive_Coding-Defensive_Coding-1-en-US-1.0-20" /><link rel="home" href="index.html" title="Defensive Coding" /><link rel="up" href="pt01.html" title="Part I. Programming Languages" /><link rel="prev" href="pt01.html" title="Part I. Programming Languages" /><link rel="next" href="sect-Defensive_Coding-C-Libc.html" title="1.2. The C standard library" /></head><body><p id="title"><a class="left" href="http://www.redhat.com"><img src="Common_Content/images/image_left.png" alt="Product Site" /></a><a class="right" href="http://docs.redhat.com"><img src="Common_Content/images/image_right.png" alt="Documentation Site" /></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="pt01.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="sect-Defensive_Coding-C-Libc.html"><strong>Next</strong></a></li></ul><div xml:lang="en-US" class="chapter" id="chap-Defensive_Coding-C" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 1. The C Programming Language</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="chap-Defensive_Coding-C.html#sect-Defensive_Coding-C-Language">1.1. The core language</a></span></dt><dd><dl><dt><span class="section"><a href="chap-Defensive_Coding-C.html#sect-Defensive_Coding-C-Undefined">1.1.1. Undefined behavior</a></span></dt><dt><span class="section"><a href="chap-Defensive_Coding-C.html#sect-Defensive_Coding-C-Pointers">1.1.2. Recommendations for pointers and array handling</a></span></dt><dt><span class="section"><a href="chap-Defensive_Coding-C.html#sect-Defensive_Coding-C-Arithmetic">1.1.3. Recommendations for integer arithmetic</a></span></dt></dl></dd><dt><span class="section"><a href="sect-Defensive_Coding-C-Libc.html">1.2. The C standard library</a></span></dt><dd><dl><dt><span class="section"><a href="sect-Defensive_Coding-C-Libc.html#sect-Defensive_Coding-C-Absolutely-Banned">1.2.1. Absolutely banned interfaces</a></span></dt><dt><span class="section"><a href="sect-Defensive_Coding-C-Avoid.html">1.2.2. Functions to avoid</a></span></dt><dt><span class="section"><a href="sect-Defensive_Coding-C-String-Functions-Length.html">1.2.3. String Functions With Explicit Length Arguments</a></span></dt></dl></dd><dt><span class="section"><a href="sect-Defensive_Coding-C-Allocators.html">1.3. Memory allocators</a></span></dt><dd><dl><dt><span class="section"><a href="sect-Defensive_Coding-C-Allocators.html#idp25109600">1.3.1. <code class="function">malloc</code> and related functions</a></span></dt><dt><span class="section"><a href="sect-Defensive_Coding-C-Allocators-alloca.html">1.3.2. <code class="function">alloca</code> and other forms of stack-based allocation</a></span></dt><dt><span class="section"><a href="sect-Defensive_Coding-C-Allocators-Arrays.html">1.3.3. Array allocation</a></span></dt><dt><span class="section"><a href="ch01s03s04.html">1.3.4. Custom memory allocators</a></span></dt><dt><span class="section"><a href="ch01s03s05.html">1.3.5. Conservative garbage collection</a></span></dt></dl></dd></dl></div><div xml:lang="en-US" class="section" id="sect-Defensive_Coding-C-Language" lang="en-US"><div class="titlepage"><div><div><h2 class="title">1.1. The core language</h2></div></div></div><div class="para">
		C provides no memory safety. Most recommendations in this section deal with this aspect of the language.
	</div><div class="section" id="sect-Defensive_Coding-C-Undefined"><div class="titlepage"><div><div><h3 class="title">1.1.1. Undefined behavior</h3></div></div></div><div class="para">
			Some C constructs are defined to be undefined by the C standard. This does not only mean that the standard does not describe what happens when the construct is executed. It also allows optimizing compilers such as GCC to assume that this particular construct is never reached. In some cases, this has caused GCC to optimize security checks away. (This is not a flaw in GCC or the C language. But C certainly has some areas which are more difficult to use than others.)
		</div><div class="para">
			Common sources of undefined behavior are:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					out-of-bounds array accesses
				</div></li><li class="listitem"><div class="para">
					null pointer dereferences
				</div></li><li class="listitem"><div class="para">
					overflow in signed integer arithmetic
				</div></li></ul></div></div><div class="section" id="sect-Defensive_Coding-C-Pointers"><div class="titlepage"><div><div><h3 class="title">1.1.2. Recommendations for pointers and array handling</h3></div></div></div><div class="para">
			Always keep track of the size of the array you are working with. Often, code is more obviously correct when you keep a pointer past the last element of the array, and calculate the number of remaining elements by substracting the current position from that pointer. The alternative, updating a separate variable every time when the position is advanced, is usually less obviously correct.
		</div><div class="para">
			<a class="xref" href="chap-Defensive_Coding-C.html#ex-Defensive_Coding-C-Pointers-remaining">Example 1.1, “Array processing in C”</a> shows how to extract Pascal-style strings from a character buffer. The two pointers kept for length checks are <code class="varname">inend</code> and <code class="varname">outend</code>. <code class="varname">inp</code> and <code class="varname">outp</code> are the respective positions. The number of input bytes is checked using the expression <code class="literal">len &gt; (size_t)(inend - inp)</code>. The cast silences a compiler warning; <code class="varname">inend</code> is always larger than <code class="varname">inp</code>.
		</div><div class="example" id="ex-Defensive_Coding-C-Pointers-remaining"><h6>Example 1.1. Array processing in C</h6><div class="example-contents"><pre xml:lang="en-US" class="programlisting" lang="en-US">
ssize_t
extract_strings(<span class="perl_DataType">const</span> <span class="perl_DataType">char</span> *in, size_t inlen, <span class="perl_DataType">char</span> **out, size_t outlen)
{
  <span class="perl_DataType">const</span> <span class="perl_DataType">char</span> *inp = in;
  <span class="perl_DataType">const</span> <span class="perl_DataType">char</span> *inend = in + inlen;
  <span class="perl_DataType">char</span> **outp = out;
  <span class="perl_DataType">char</span> **outend = out + outlen;

  <span class="perl_Keyword">while</span> (inp != inend) {
    size_t len;
    <span class="perl_DataType">char</span> *s;
    <span class="perl_Keyword">if</span> (outp == outend) {
      errno = ENOSPC;
      <span class="perl_Keyword">goto</span> err;
    }
    len = (<span class="perl_DataType">unsigned</span> <span class="perl_DataType">char</span>)*inp;
    ++inp;
    <span class="perl_Keyword">if</span> (len &gt; (size_t)(inend - inp)) {
      errno = EINVAL;
      <span class="perl_Keyword">goto</span> err;
    }
    s = malloc(len + <span class="perl_Float">1</span>);
    <span class="perl_Keyword">if</span> (s == NULL) {
      <span class="perl_Keyword">goto</span> err;
    }
    memcpy(s, inp, len);
    inp += len;
    s[len] = '\0';
    *outp = s;
    ++outp;
  }
  <span class="perl_Keyword">return</span> outp - out;
err:
  {
    <span class="perl_DataType">int</span> errno_old = errno;
    <span class="perl_Keyword">while</span> (out != outp) {
      free(*out);
      ++out;
    }
    errno = errno_old;
  }
  <span class="perl_Keyword">return</span> <span class="perl_DecVal">-1</span>;
}
</pre></div></div><br class="example-break" /><div class="para">
			It is important that the length checks always have the form <code class="literal">len &gt; (size_t)(inend - inp)</code>, where <code class="varname">len</code> is a variable of type <span class="type">size_t</span> which denotes the <span class="emphasis"><em>total</em></span> number of bytes which are about to be read or written next. In general, it is not safe to fold multiple such checks into one, as in <code class="literal">len1 + len2 &gt; (size_t)(inend - inp)</code>, because the expression on the left can overflow or wrap around (see <a class="xref" href="chap-Defensive_Coding-C.html#sect-Defensive_Coding-C-Arithmetic">Section 1.1.3, “Recommendations for integer arithmetic”</a>), and it no longer reflects the number of bytes to be processed.
		</div></div><div class="section" id="sect-Defensive_Coding-C-Arithmetic"><div class="titlepage"><div><div><h3 class="title">1.1.3. Recommendations for integer arithmetic</h3></div></div></div><div class="para">
			Overflow in signed integer arithmetic is undefined. This means that it is not possible to check for overflow after it happened, see <a class="xref" href="chap-Defensive_Coding-C.html#ex-Defensive_Coding-C-Arithmetic-bad">Example 1.2, “Incorrect overflow detection in C”</a>.
		</div><div class="example" id="ex-Defensive_Coding-C-Arithmetic-bad"><h6>Example 1.2. Incorrect overflow detection in C</h6><div class="example-contents"><pre xml:lang="en-US" class="programlisting" lang="en-US">
<span class="perl_DataType">void</span> report_overflow(<span class="perl_DataType">void</span>);

<span class="perl_DataType">int</span>
add(<span class="perl_DataType">int</span> a, <span class="perl_DataType">int</span> b)
{
  <span class="perl_DataType">int</span> result = a + b;
  <span class="perl_Keyword">if</span> (a &lt; 0 || b &lt; 0) {
    <span class="perl_Keyword">return</span> <span class="perl_DecVal">-1</span>;
  }
  <span class="perl_Comment">// The compiler can optimize away the following if statement.</span><span class="perl_Comment"></span>
<span class="perl_Comment"></span>  <span class="perl_Keyword">if</span> (result &lt; 0) {
    report_overflow();
  }
  <span class="perl_Keyword">return</span> result;
}
</pre></div></div><br class="example-break" /><div class="para">
			The following approaches can be used to check for overflow, without actually causing it.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					Use a wider type to perform the calculation, check that the result is within bounds, and convert the result to the original type. All intermediate results must be checked in this way.
				</div></li><li class="listitem"><div class="para">
					Perform the calculation in the corresponding unsigned type and use bit fiddling to detect the overflow.
				</div></li><li class="listitem"><div class="para">
					Compute bounds for acceptable input values which are known to avoid overflow, and reject other values. This is the preferred way for overflow checking on multiplications, see <a class="xref" href="chap-Defensive_Coding-C.html#ex-Defensive_Coding-C-Arithmetic-mult">Example 1.3, “Overflow checking for unsigned multiplication”</a>. 
				</div></li></ul></div><div class="example" id="ex-Defensive_Coding-C-Arithmetic-mult"><h6>Example 1.3. Overflow checking for unsigned multiplication</h6><div class="example-contents"><pre xml:lang="en-US" class="programlisting" lang="en-US">
<span class="perl_DataType">unsigned</span>
mul(<span class="perl_DataType">unsigned</span> a, <span class="perl_DataType">unsigned</span> b)
{
  <span class="perl_Keyword">if</span> (b &amp;&amp; a &gt; ((<span class="perl_DataType">unsigned</span>)<span class="perl_DecVal">-1</span>) / b) {
    report_overflow();
  }
  <span class="perl_Keyword">return</span> a * b;
}
</pre></div></div><br class="example-break" /><div class="para">
			Basic arithmetic operations a commutative, so for bounds checks, there are two different but mathematically equivalent expressions. Sometimes, one of the expressions results in better code because parts of it can be reduced to a constant. This applies to overflow checks for multiplication <code class="literal">a * b</code> involving a constant <code class="literal">a</code>, where the expression is reduced to <code class="literal">b &gt; C</code> for some constant <code class="literal">C</code> determined at compile time. The other expression, <code class="literal">b &amp;&amp; a &gt; ((unsigned)-1) / b</code>, is more difficult to optimize at compile time.
		</div><div class="para">
			When a value is converted to a signed integer, GCC always chooses the result based on 2's complement arithmetic. This GCC extension (which is also implemented by other compilers) helps a lot when implementing overflow checks.
		</div><div class="para">
			Legacy code should be compiled with the <code class="option">-fwrapv</code> GCC option. As a result, GCC will provide 2's complement semantics for integer arithmetic, including defined behavior on integer overflow.
		</div></div></div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="pt01.html"><strong>Prev</strong>Part I. Programming Languages</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="sect-Defensive_Coding-C-Libc.html"><strong>Next</strong>1.2. The C standard library</a></li></ul></body></html>