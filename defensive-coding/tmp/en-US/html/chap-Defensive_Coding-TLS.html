<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 12. Transport Layer Security</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 2.8" /><meta name="package" content="Defensive_Coding-Defensive_Coding-1-en-US-1.0-20" /><link rel="home" href="index.html" title="Defensive Coding" /><link rel="up" href="pt03.html" title="Part III. Implementing Security Features" /><link rel="prev" href="sect-Defensive_Coding-Authentication-Netlink.html" title="11.4. AF_NETLINK authentication of origin" /><link rel="next" href="sect-Defensive_Coding-TLS-Client.html" title="12.2. TLS Clients" /></head><body><p id="title"><a class="left" href="http://www.redhat.com"><img src="Common_Content/images/image_left.png" alt="Product Site" /></a><a class="right" href="http://docs.redhat.com"><img src="Common_Content/images/image_right.png" alt="Documentation Site" /></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="sect-Defensive_Coding-Authentication-Netlink.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="sect-Defensive_Coding-TLS-Client.html"><strong>Next</strong></a></li></ul><div xml:lang="en-US" class="chapter" id="chap-Defensive_Coding-TLS" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 12. Transport Layer Security</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="chap-Defensive_Coding-TLS.html#sect-Defensive_Coding-TLS-Pitfalls">12.1. Common Pitfalls</a></span></dt><dd><dl><dt><span class="section"><a href="chap-Defensive_Coding-TLS.html#sect-Defensive_Coding-TLS-OpenSSL">12.1.1. OpenSSL Pitfalls</a></span></dt><dt><span class="section"><a href="chap-Defensive_Coding-TLS.html#sect-Defensive_Coding-TLS-Pitfalls-GNUTLS">12.1.2. GNUTLS Pitfalls</a></span></dt><dt><span class="section"><a href="chap-Defensive_Coding-TLS.html#sect-Defensive_Coding-TLS-Pitfalls-OpenJDK">12.1.3. OpenJDK Pitfalls</a></span></dt><dt><span class="section"><a href="chap-Defensive_Coding-TLS.html#sect-Defensive_Coding-TLS-Pitfalls-NSS">12.1.4. NSS Pitfalls</a></span></dt></dl></dd><dt><span class="section"><a href="sect-Defensive_Coding-TLS-Client.html">12.2. TLS Clients</a></span></dt><dd><dl><dt><span class="section"><a href="sect-Defensive_Coding-TLS-Client.html#idp21225024">12.2.1. Implementation TLS Clients With OpenSSL</a></span></dt><dt><span class="section"><a href="sect-Defensive_Coding-TLS-Client-GNUTLS.html">12.2.2. Implementation TLS Clients With GNUTLS</a></span></dt><dt><span class="section"><a href="sect-Defensive_Coding-TLS-Client-OpenJDK.html">12.2.3. Implementing TLS Clients With OpenJDK</a></span></dt><dt><span class="section"><a href="sect-Defensive_Coding-TLS-Client-NSS.html">12.2.4. Implementing TLS Clients With NSS</a></span></dt><dt><span class="section"><a href="sect-Defensive_Coding-TLS-Client-Python.html">12.2.5. Implementing TLS Clients With Python</a></span></dt></dl></dd></dl></div><div class="para">
		Transport Layer Security (TLS, formerly Secure Sockets Layer/SSL) is the recommended way to to protect integrity and confidentiality while data is transferred over an untrusted network connection, and to identify the endpoint.
	</div><div class="section" id="sect-Defensive_Coding-TLS-Pitfalls"><div class="titlepage"><div><div><h2 class="title">12.1. Common Pitfalls</h2></div></div></div><div class="para">
			TLS implementations are difficult to use, and most of them lack a clean API design. The following sections contain implementation-specific advice, and some generic pitfalls are mentioned below.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					Most TLS implementations have questionable default TLS cipher suites. Most of them enable anonymous Diffie-Hellman key exchange (but we generally want servers to authenticate themselves). Many do not disable ciphers which are subject to brute-force attacks because of restricted key lengths. Some even disable all variants of AES in the default configuration.
				</div><div class="para">
					When overriding the cipher suite defaults, it is recommended to disable all cipher suites which are not present on a whitelist, instead of simply enabling a list of cipher suites. This way, if an algorithm is disabled by default in the TLS implementation in a future security update, the application will not re-enable it.
				</div></li><li class="listitem"><div class="para">
					The name which is used in certificate validation must match the name provided by the user or configuration file. No host name canonicalization or IP address lookup must be performed.
				</div></li><li class="listitem"><div class="para">
					The TLS handshake has very poor performance if the TCP Nagle algorithm is active. You should switch on the <code class="literal">TCP_NODELAY</code> socket option (at least for the duration of the handshake), or use the Linux-specific <code class="literal">TCP_CORK</code> option.
				</div><div class="example" id="ex-Defensive_Coding-TLS-Nagle"><h6>Example 12.1. Deactivating the TCP Nagle algorithm</h6><div class="example-contents"><pre xml:lang="en-US" class="programlisting" lang="en-US">
<span class="perl_DataType">const</span> <span class="perl_DataType">int</span> val = <span class="perl_Float">1</span>;
<span class="perl_DataType">int</span> ret = setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &amp;val, <span class="perl_Keyword">sizeof</span>(val));
<span class="perl_Keyword">if</span> (ret &lt; 0) {
  perror(<span class="perl_String">"setsockopt(TCP_NODELAY)"</span>);
  exit(<span class="perl_Float">1</span>);
}
</pre></div></div><br class="example-break" /></li><li class="listitem"><div class="para">
					Implementing proper session resumption decreases handshake overhead considerably. This is important if the upper-layer protocol uses short-lived connections (like most application of HTTPS).
				</div></li><li class="listitem"><div class="para">
					Both client and server should work towards an orderly connection shutdown, that is send <code class="literal">close_notify</code> alerts and respond to them. This is especially important if the upper-layer protocol does not provide means to detect connection truncation (like some uses of HTTP).
				</div></li><li class="listitem"><div class="para">
					When implementing a server using event-driven programming, it is important to handle the TLS handshake properly because it includes multiple network round-trips which can block when an ordinary TCP <code class="function">accept</code> would not. Otherwise, a client which fails to complete the TLS handshake for some reason will prevent the server from handling input from other clients.
				</div></li><li class="listitem"><div class="para">
					Unlike regular file descriptors, TLS connections cannot be passed between processes. Some TLS implementations add additional restrictions, and TLS connections generally cannot be used across <code class="function">fork</code> function calls (see <a class="xref" href="sect-Defensive_Coding-Tasks-Processes-Fork-Parallel.html">Section 8.6, “<code class="function">fork</code> as a primitive for parallelism”</a>).
				</div></li></ul></div><div class="section" id="sect-Defensive_Coding-TLS-OpenSSL"><div class="titlepage"><div><div><h3 class="title">12.1.1. OpenSSL Pitfalls</h3></div></div></div><div class="para">
				Some OpenSSL function use <span class="emphasis"><em>tri-state return values</em></span>. Correct error checking is extremely important. Several functions return <code class="literal">int</code> values with the following meaning:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						The value <code class="literal">1</code> indicates success (for example, a successful signature verification).
					</div></li><li class="listitem"><div class="para">
						The value <code class="literal">0</code> indicates semantic failure (for example, a signature verification which was unsuccessful because the signing certificate was self-signed).
					</div></li><li class="listitem"><div class="para">
						The value <code class="literal">-1</code> indicates a low-level error in the system, such as failure to allocate memory using <code class="function">malloc</code>.
					</div></li></ul></div><div class="para">
				Treating such tri-state return values as booleans can lead to security vulnerabilities. Note that some OpenSSL functions return boolean results or yet another set of status indicators. Each function needs to be checked individually.
			</div><div class="para">
				Recovering precise error information is difficult. <a class="xref" href="chap-Defensive_Coding-TLS.html#ex-Defensive_Coding-TLS-OpenSSL-Errors">Example 12.2, “Obtaining OpenSSL error codes”</a> shows how to obtain a more precise error code after a function call on an <code class="literal">SSL</code> object has failed. However, there are still cases where no detailed error information is available (e.g., if <code class="function">SSL_shutdown</code> fails due to a connection teardown by the other end).
			</div><div class="example" id="ex-Defensive_Coding-TLS-OpenSSL-Errors"><h6>Example 12.2. Obtaining OpenSSL error codes</h6><div class="example-contents"><pre xml:lang="en-US" class="programlisting" lang="en-US">
<span class="perl_DataType">static</span> <span class="perl_DataType">void</span> __attribute__((noreturn))
ssl_print_error_and_exit(SSL *ssl, <span class="perl_DataType">const</span> <span class="perl_DataType">char</span> *op, <span class="perl_DataType">int</span> ret)
{
  <span class="perl_DataType">int</span> subcode = SSL_get_error(ssl, ret);
  <span class="perl_Keyword">switch</span> (subcode) {
  <span class="perl_Keyword">case</span> SSL_ERROR_NONE:
    fprintf(stderr, <span class="perl_String">"error: %s: no error to report</span><span class="perl_Char">\n</span><span class="perl_String">"</span>, op);
    <span class="perl_Keyword">break</span>;
  <span class="perl_Keyword">case</span> SSL_ERROR_WANT_READ:
  <span class="perl_Keyword">case</span> SSL_ERROR_WANT_WRITE:
  <span class="perl_Keyword">case</span> SSL_ERROR_WANT_X509_LOOKUP:
  <span class="perl_Keyword">case</span> SSL_ERROR_WANT_CONNECT:
  <span class="perl_Keyword">case</span> SSL_ERROR_WANT_ACCEPT:
    fprintf(stderr, <span class="perl_String">"error: %s: invalid blocking state %d</span><span class="perl_Char">\n</span><span class="perl_String">"</span>, op, subcode);
    <span class="perl_Keyword">break</span>;
  <span class="perl_Keyword">case</span> SSL_ERROR_SSL:
    fprintf(stderr, <span class="perl_String">"error: %s: TLS layer problem</span><span class="perl_Char">\n</span><span class="perl_String">"</span>, op);
  <span class="perl_Keyword">case</span> SSL_ERROR_SYSCALL:
    fprintf(stderr, <span class="perl_String">"error: %s: system call failed: %s</span><span class="perl_Char">\n</span><span class="perl_String">"</span>, op, strerror(errno));
    <span class="perl_Keyword">break</span>;
  <span class="perl_Keyword">case</span> SSL_ERROR_ZERO_RETURN:
    fprintf(stderr, <span class="perl_String">"error: %s: zero return</span><span class="perl_Char">\n</span><span class="perl_String">"</span>, op);
  }
  exit(<span class="perl_Float">1</span>);
}
</pre></div></div><br class="example-break" /><div class="para">
				The <code class="function">OPENSSL_config</code> function is documented to never fail. In reality, it can terminate the entire process if there is a failure accessing the configuration file. An error message is written to standard error, but which might not be visible if the function is called from a daemon process.
			</div><div class="para">
				OpenSSL contains two separate ASN.1 DER decoders. One set of decoders operate on BIO handles (the input/output stream abstraction provided by OpenSSL); their decoder function names start with <code class="literal">d2i_</code> and end in <code class="literal">_fp</code> or <code class="literal">_bio</code> (e.g., <code class="function">d2i_X509_fp</code> or <code class="function">d2i_X509_bio</code>). These decoders must not be used for parsing data from untrusted sources; instead, the variants without the <code class="literal">_fp</code> and <code class="literal">_bio</code> (e.g., <code class="function">d2i_X509</code>) shall be used. The BIO variants have received considerably less testing and are not very robust.
			</div><div class="para">
				For the same reason, the OpenSSL command line tools (such as <code class="command">openssl x509</code>) are generally generally less robust than the actual library code. They use the BIO functions internally, and not the more robust variants.
			</div><div class="para">
				The command line tools do not always indicate failure in the exit status of the <span class="application"><strong>openssl</strong></span> process. For instance, a verification failure in <code class="command">openssl verify</code> result in an exit status of zero.
			</div><div class="para">
				The OpenSSL server and client applications (<code class="command">openssl s_client</code> and <code class="command">openssl s_server</code>) are debugging tools and should <span class="emphasis"><em>never</em></span> be used as generic clients. For instance, the <span class="application"><strong>s_client</strong></span> tool reacts in a surprisign way to lines starting with <code class="literal">R</code> and <code class="literal">Q</code>.
			</div><div class="para">
				OpenSSL allows application code to access private key material over documented interfaces. This can significantly increase the part of the code base which has to undergo security certification.
			</div></div><div class="section" id="sect-Defensive_Coding-TLS-Pitfalls-GNUTLS"><div class="titlepage"><div><div><h3 class="title">12.1.2. GNUTLS Pitfalls</h3></div></div></div><div class="para">
				<code class="filename">libgnutls.so.26</code> links to <code class="filename">libpthread.so.0</code>. Loading the threading library too late causes problems, so the main program should be linked with <code class="literal">-lpthread</code> as well. As a result, it can be difficult to use GNUTLS in a plugin which is loaded with the <code class="function">dlopen</code> function. Another side effect is that applications which merely link against GNUTLS (even without actually using it) may incur a substantial overhead because other libraries automatically switch to thread-safe algorithms.
			</div><div class="para">
				The <code class="function">gnutls_global_init</code> function must be called before using any functionality provided by the library. This function is not thread-safe, so external locking is required, but it is not clear which lock should be used. Omitting the synchronization does not just lead to a memory leak, as it is suggested in the GNUTLS documentation, but to undefined behavior because there is no barrier that would enforce memory ordering.
			</div><div class="para">
				The <code class="function">gnutls_global_deinit</code> function does not actually deallocate all resources allocated by <code class="function">gnutls_global_init</code>. It is currently not thread-safe. Therefore, it is best to avoid calling it altogether.
			</div><div class="para">
				The X.509 implementation in GNUTLS is rather lenient. For example, it is possible to create and process X.509 version 1 certificates which carry extensions. These certificates are (correctly) rejected by other implementations.
			</div></div><div class="section" id="sect-Defensive_Coding-TLS-Pitfalls-OpenJDK"><div class="titlepage"><div><div><h3 class="title">12.1.3. OpenJDK Pitfalls</h3></div></div></div><div class="para">
				The Java cryptographic framework is highly modular. As a result, when you request an object implementing some cryptographic functionality, you cannot be completely sure that you end up with the well-tested, reviewed implementation in OpenJDK.
			</div><div class="para">
				OpenJDK (in the source code as published by Oracle) and other implementations of the Java platform require that the system administrator has installed so-called <span class="emphasis"><em>unlimited strength jurisdiction policy files</em></span>. Without this step, it is not possible to use the secure algorithms which offer sufficient cryptographic strength. Most downstream redistributors of OpenJDK remove this requirement.
			</div><div class="para">
				Some versions of OpenJDK use <code class="filename">/dev/random</code> as the randomness source for nonces and other random data which is needed for TLS operation, but does not actually require physical randomness. As a result, TLS applications can block, waiting for more bits to become available in <code class="filename">/dev/random</code>.
			</div></div><div class="section" id="sect-Defensive_Coding-TLS-Pitfalls-NSS"><div class="titlepage"><div><div><h3 class="title">12.1.4. NSS Pitfalls</h3></div></div></div><div class="para">
				NSS was not designed to be used by other libraries which can be linked into applications without modifying them. There is a lot of global state. There does not seem to be a way to perform required NSS initialization without race conditions.
			</div><div class="para">
				If the NSPR descriptor is in an unexpected state, the <code class="function">SSL_ForceHandshake</code> function can succeed, but no TLS handshake takes place, the peer is not authenticated, and subsequent data is exchanged in the clear.
			</div><div class="para">
				NSS disables itself if it detects that the process underwent a <code class="function">fork</code> after the library has been initialized. This behavior is required by the PKCS#11 API specification.
			</div></div></div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="sect-Defensive_Coding-Authentication-Netlink.html"><strong>Prev</strong>11.4. AF_NETLINK authentication of origin</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="sect-Defensive_Coding-TLS-Client.html"><strong>Next</strong>12.2. TLS Clients</a></li></ul></body></html>