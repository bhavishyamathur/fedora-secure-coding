<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 6. File system manipulation</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 2.8" /><meta name="package" content="Defensive_Coding-Defensive_Coding-1-en-US-1.0-20" /><link rel="home" href="index.html" title="Defensive Coding" /><link rel="up" href="pt02.html" title="Part II. Specific Programming Tasks" /><link rel="prev" href="sect-Defensive_Coding-Tasks-Descriptors-Limit.html" title="5.3. Dealing with the select limit" /><link rel="next" href="sect-Defensive_Coding-Tasks-File_System-Foreign.html" title="6.2. Accessing the file system as a different user" /></head><body><p id="title"><a class="left" href="http://www.redhat.com"><img src="Common_Content/images/image_left.png" alt="Product Site" /></a><a class="right" href="http://docs.redhat.com"><img src="Common_Content/images/image_right.png" alt="Documentation Site" /></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="sect-Defensive_Coding-Tasks-Descriptors-Limit.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="sect-Defensive_Coding-Tasks-File_System-Foreign.html"><strong>Next</strong></a></li></ul><div xml:lang="en-US" class="chapter" id="chap-Defensive_Coding-Tasks-File_System" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 6. File system manipulation</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="chap-Defensive_Coding-Tasks-File_System.html#sect-Defensive_Coding-Tasks-File_System-Unowned">6.1. Working with files and directories owned by other users</a></span></dt><dt><span class="section"><a href="sect-Defensive_Coding-Tasks-File_System-Foreign.html">6.2. Accessing the file system as a different user</a></span></dt><dt><span class="section"><a href="sect-Defensive_Coding-Tasks-File_System-Limits.html">6.3. File system limits</a></span></dt><dt><span class="section"><a href="sect-Defensive_Coding-Tasks-File_System-Features.html">6.4. File system features</a></span></dt><dt><span class="section"><a href="sect-Defensive_Coding-Tasks-File_System-Free_Space.html">6.5. Checking free space</a></span></dt></dl></div><div class="para">
		In this chapter, we discuss general file system manipulation, with a focus on access files and directories to which an other, potentially untrusted user has write access.
	</div><div class="para">
		Temporary files are covered in their own chapter, <a class="xref" href="chap-Defensive_Coding-Tasks-Temporary_Files.html">Chapter 7, <em>Temporary files</em></a>.
	</div><div class="section" id="sect-Defensive_Coding-Tasks-File_System-Unowned"><div class="titlepage"><div><div><h2 class="title">6.1. Working with files and directories owned by other users</h2></div></div></div><div class="para">
			Sometimes, it is necessary to operate on files and directories owned by other (potentially untrusted) users. For example, a system administrator could remove the home directory of a user, or a package manager could update a file in a directory which is owned by an application-specific user. This differs from accessing the file system as a specific user; see <a class="xref" href="sect-Defensive_Coding-Tasks-File_System-Foreign.html">Section 6.2, “Accessing the file system as a different user”</a>.
		</div><div class="para">
			Accessing files across trust boundaries faces several challenges, particularly if an entire directory tree is being traversed:
		</div><div class="orderedlist"><ol><li class="listitem"><div class="para">
					Another user might add file names to a writable directory at any time. This can interfere with file creation and the order of names returned by <code class="function">readdir</code>.
				</div></li><li class="listitem"><div class="para">
					Merely opening and closing a file can have side effects. For instance, an automounter can be triggered, or a tape device rewound. Opening a file on a local file system can block indefinitely, due to mandatory file locking, unless the <code class="literal">O_NONBLOCK</code> flag is specified.
				</div></li><li class="listitem"><div class="para">
					Hard links and symbolic links can redirect the effect of file system operations in unexpected ways. The <code class="literal">O_NOFOLLOW</code> and <code class="literal">AT_SYMLINK_NOFOLLOW</code> variants of system calls only affected final path name component.
				</div></li><li class="listitem"><div class="para">
					The structure of a directory tree can change. For example, the parent directory of what used to be a subdirectory within the directory tree being processed could suddenly point outside that directory tree.
				</div></li></ol></div><div class="para">
			Files should always be created with the <code class="literal">O_CREAT</code> and <code class="literal">O_EXCL</code> flags, so that creating the file will fail if it already exists. This guards against the unexpected appearance of file names, either due to creation of a new file, or hard-linking of an existing file. In multi-threaded programs, rather than manipulating the umask, create the files with mode <code class="literal">000</code> if possible, and adjust it afterwards with <code class="function">fchmod</code>.
		</div><div class="para">
			To avoid issues related to symbolic links and directory tree restructuring, the “<code class="literal">at</code>” variants of system calls have to be used (that is, functions like <code class="function">openat</code>, <code class="function">fchownat</code>, <code class="function">fchmodat</code>, and <code class="function">unlinkat</code>, together with <code class="literal">O_NOFOLLOW</code> or <code class="literal">AT_SYMLINK_NOFOLLOW</code>). Path names passed to these functions must have just a single component (that is, without a slash). When descending, the descriptors of parent directories must be kept open. The missing <code class="literal">opendirat</code> function can be emulated with <code class="literal">openat</code> (with an <code class="literal">O_DIRECTORY</code> flag, to avoid opening special files with side effects), followed by <code class="literal">fdopendir</code>.
		</div><div class="para">
			If the “<code class="literal">at</code>” functions are not available, it is possible to emulate them by changing the current directory. (Obviously, this only works if the process is not multi-threaded.) <code class="function">fchdir</code> has to be used to change the current directory, and the descriptors of the parent directories have to be kept open, just as with the “<code class="literal">at</code>”-based approach. <code class="literal">chdir("...")</code> is unsafe because it might ascend outside the intended directory tree.
		</div><div class="para">
			This “<code class="literal">at</code>” function emulation is currently required when manipulating extended attributes. In this case, the <code class="function">lsetxattr</code> function can be used, with a relative path name consisting of a single component. This also applies to SELinux contexts and the <code class="function">lsetfilecon</code> function.
		</div><div class="para">
			Currently, it is not possible to avoid opening special files <span class="emphasis"><em>and</em></span> changes to files with hard links if the directory containing them is owned by an untrusted user. (Device nodes can be hard-linked, just as regular files.) <code class="function">fchmodat</code> and <code class="function">fchownat</code> affect files whose link count is greater than one. But opening the files, checking that the link count is one with <code class="function">fstat</code>, and using <code class="function">fchmod</code> and <code class="function">fchown</code> on the file descriptor may have unwanted side effects, due to item 2 above. When creating directories, it is therefore important to change the ownership and permissions only after it has been fully created. Until that point, file names are stable, and no files with unexpected hard links can be introduced.
		</div><div class="para">
			Similarly, when just reading a directory owned by an untrusted user, it is currently impossible to reliably avoid opening special files.
		</div><div class="para">
			There is no workaround against the instability of the file list returned by <code class="function">readdir</code>. Concurrent modification of the directory can result in a list of files being returned which never actually existed on disk.
		</div><div class="para">
			Hard links and symbolic links can be safely deleted using <code class="function">unlinkat</code> without further checks because deletion only affects the name within the directory tree being processed.
		</div></div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="sect-Defensive_Coding-Tasks-Descriptors-Limit.html"><strong>Prev</strong>5.3. Dealing with the select limit</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="sect-Defensive_Coding-Tasks-File_System-Foreign.html"><strong>Next</strong>6.2. Accessing the file system as a different user</a></li></ul></body></html>