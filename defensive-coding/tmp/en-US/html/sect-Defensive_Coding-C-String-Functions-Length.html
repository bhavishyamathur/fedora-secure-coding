<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>1.2.3. String Functions With Explicit Length Arguments</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 2.8" /><meta name="package" content="Defensive_Coding-Defensive_Coding-1-en-US-1.0-20" /><link rel="home" href="index.html" title="Defensive Coding" /><link rel="up" href="sect-Defensive_Coding-C-Libc.html" title="1.2. The C standard library" /><link rel="prev" href="sect-Defensive_Coding-C-Avoid.html" title="1.2.2. Functions to avoid" /><link rel="next" href="sect-Defensive_Coding-C-Allocators.html" title="1.3. Memory allocators" /></head><body><p id="title"><a class="left" href="http://www.redhat.com"><img src="Common_Content/images/image_left.png" alt="Product Site" /></a><a class="right" href="http://docs.redhat.com"><img src="Common_Content/images/image_right.png" alt="Documentation Site" /></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="sect-Defensive_Coding-C-Avoid.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="sect-Defensive_Coding-C-Allocators.html"><strong>Next</strong></a></li></ul><div class="section" id="sect-Defensive_Coding-C-String-Functions-Length"><div class="titlepage"><div><div><h3 class="title">1.2.3. String Functions With Explicit Length Arguments</h3></div></div></div><div class="para">
			The <code class="function">snprintf</code> function provides a way to construct a string in a statically-sized buffer. (If the buffer size is dynamic, use <code class="function">asprintf</code> instead.)
		</div><div class="informalexample"><pre xml:lang="en-US" class="programlisting" lang="en-US">
<span class="perl_DataType">char</span> fraction[<span class="perl_Float">30</span>];
snprintf(fraction, <span class="perl_Keyword">sizeof</span>(fraction), <span class="perl_String">"%d/%d"</span>, numerator, denominator);
</pre></div><div class="para">
			The second argument to the <code class="function">snprintf</code> should always be the size of the buffer in the first argument (which should be a character array). Complex pointer and length arithmetic can introduce errors and nullify the security benefits of <code class="function">snprintf</code>. If you need to construct a string iteratively, by repeatedly appending fragments, consider constructing the string on the heap, increasing the buffer with <code class="function">realloc</code> as needed. (<code class="function">snprintf</code> does not support overlapping the result buffer with argument strings.)
		</div><div class="para">
			If you use <code class="function">vsnprintf</code> (or <code class="function">snprintf</code>) with a format string which is not a constant, but a function argument, it is important to annotate the function with a <code class="literal">format</code> function attribute, so that GCC can warn about misuse of your function (see <a class="xref" href="sect-Defensive_Coding-C-String-Functions-Length.html#ex-Defensive_Coding-C-String-Functions-format-Attribute">Example 1.4, “The <code class="literal">format</code> function attribute”</a>).
		</div><div class="example" id="ex-Defensive_Coding-C-String-Functions-format-Attribute"><h6>Example 1.4. The <code class="literal">format</code> function attribute</h6><div class="example-contents"><pre xml:lang="en-US" class="programlisting" lang="en-US">
<span class="perl_DataType">void</span> log_format(<span class="perl_DataType">const</span> <span class="perl_DataType">char</span> *format, ...) __attribute__((format(printf, <span class="perl_Float">1</span>, <span class="perl_Float">2</span>)));

<span class="perl_DataType">void</span>
log_format(<span class="perl_DataType">const</span> <span class="perl_DataType">char</span> *format, ...)
{
  <span class="perl_DataType">char</span> buf[<span class="perl_Float">1000</span>];
  va_list ap;
  va_start(ap, format);
  vsnprintf(buf, <span class="perl_Keyword">sizeof</span>(buf), format, ap);
  va_end(ap);
  log_string(buf);
}
</pre></div></div><br class="example-break" /><div class="para">
			There are other functions which operator on NUL-terminated strings and take a length argument which affects the number of bytes written to the destination: <code class="function">strncpy</code>, <code class="function">strncat</code>, and <code class="function">stpncpy</code>. These functions do not ensure that the result string is NUL-terminated. For <code class="function">strncpy</code>, NUL termination can be added this way:
		</div><div class="informalexample"><pre xml:lang="en-US" class="programlisting" lang="en-US">
<span class="perl_DataType">char</span> buf[<span class="perl_Float">10</span>];
strncpy(buf, data, <span class="perl_Keyword">sizeof</span>(buf));
buf[<span class="perl_Keyword">sizeof</span>(buf) - <span class="perl_Float">1</span>] = '\0';
</pre></div><div class="para">
			Some systems support <code class="function">strlcpy</code> and <code class="function">strlcat</code> functions which behave this way, but these functions are not part of GNU libc. Using <code class="function">snprintf</code> with a suitable format string is a simple (albeit slightly slower) replacement.
		</div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="sect-Defensive_Coding-C-Avoid.html"><strong>Prev</strong>1.2.2. Functions to avoid</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="sect-Defensive_Coding-C-Allocators.html"><strong>Next</strong>1.3. Memory allocators</a></li></ul></body></html>