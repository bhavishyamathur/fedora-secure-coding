<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>6.4. File system features</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 2.8" /><meta name="package" content="Defensive_Coding-Defensive_Coding-1-en-US-1.0-20" /><link rel="home" href="index.html" title="Defensive Coding" /><link rel="up" href="chap-Defensive_Coding-Tasks-File_System.html" title="Chapter 6. File system manipulation" /><link rel="prev" href="sect-Defensive_Coding-Tasks-File_System-Limits.html" title="6.3. File system limits" /><link rel="next" href="sect-Defensive_Coding-Tasks-File_System-Free_Space.html" title="6.5. Checking free space" /></head><body><p id="title"><a class="left" href="http://www.redhat.com"><img src="Common_Content/images/image_left.png" alt="Product Site" /></a><a class="right" href="http://docs.redhat.com"><img src="Common_Content/images/image_right.png" alt="Documentation Site" /></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="sect-Defensive_Coding-Tasks-File_System-Limits.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="sect-Defensive_Coding-Tasks-File_System-Free_Space.html"><strong>Next</strong></a></li></ul><div class="section" id="sect-Defensive_Coding-Tasks-File_System-Features"><div class="titlepage"><div><div><h2 class="title">6.4. File system features</h2></div></div></div><div class="para">
			Not all file systems support all features. This makes it very difficult to write general-purpose tools for copying files. For example, a copy operation intending to preserve file permissions will generally fail when copying to a FAT file system.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					Some file systems are case-insensitive. Most should be case-preserving, though.
				</div></li><li class="listitem"><div class="para">
					Name length limits vary greatly, from eight to thousands of bytes. Path length limits differ as well. Most systems impose an upper bound on path names passed to the kernel, but using relative path names, it is possible to create and access files whose absolute path name is essentially of unbounded length.
				</div></li><li class="listitem"><div class="para">
					Some file systems do not store names as fairly unrestricted byte sequences, as it has been traditionally the case on GNU systems. This means that some byte sequences (outside the POSIX safe character set) are not valid names. Conversely, names of existing files may not be representable as byte sequences, and the files are thus inaccessible on GNU systems. Some file systems perform Unicode canonicalization on file names. These file systems preserve case, but reading the name of a just-created file using <code class="function">readdir</code> might still result in a different byte sequence.
				</div></li><li class="listitem"><div class="para">
					Permissions and owners are not universally supported (and SUID/SGID bits may not be available). For example, FAT file systems assign ownership based on a mount option, and generally mark all files as executable. Any attempt to change permissions would result in an error.
				</div></li><li class="listitem"><div class="para">
					Non-regular files (device nodes, FIFOs) are not generally available.
				</div></li><li class="listitem"><div class="para">
					Only on some file systems, files can have holes, that is, not all of their contents is backed by disk storage.
				</div></li><li class="listitem"><div class="para">
					<code class="function">ioctl</code> support (even fairly generic functionality such as <code class="literal">FIEMAP</code> for discovering physical file layout and holes) is file-system-specific.
				</div></li><li class="listitem"><div class="para">
					Not all file systems support extended attributes, ACLs and SELinux metadata. Size and naming restriction on extended attributes vary.
				</div></li><li class="listitem"><div class="para">
					Hard links may not be supported at all (FAT) or only within the same directory (AFS). Symbolic links may not be available, either. Reflinks (hard links with copy-on-write semantics) are still very rare. Recent systems restrict creation of hard links to users which own the target file or have read/write access to it, but older systems do not.
				</div></li><li class="listitem"><div class="para">
					Renaming (or moving) files using <code class="function">rename</code> can fail (even when <code class="function">stat</code> indicates that the source and target directories are located on the same file system). This system call should work if the old and new paths are located in the same directory, though.
				</div></li><li class="listitem"><div class="para">
					Locking semantics vary among file systems. This affects advisory and mandatory locks. For example, some network file systems do not allow deleting files which are opened by any process.
				</div></li><li class="listitem"><div class="para">
					Resolution of time stamps varies from two seconds to nanoseconds. Not all time stamps are available on all file systems. File creation time (<span class="emphasis"><em>birth time</em></span>) is not exposed over the <code class="function">stat</code>/<code class="function">fstat</code> interface, even if stored by the file system.
				</div></li></ul></div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="sect-Defensive_Coding-Tasks-File_System-Limits.html"><strong>Prev</strong>6.3. File system limits</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="sect-Defensive_Coding-Tasks-File_System-Free_Space.html"><strong>Next</strong>6.5. Checking free space</a></li></ul></body></html>